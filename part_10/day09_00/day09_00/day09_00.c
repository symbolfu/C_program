#define _CRT_SECURE_NO_WARNINGS 1

/*
	对文件的输入输出：
		类型：
			程序文件
			数据文件
		本章主要讨论数据文件：
		
		文件：
			一般指存储在外部介质上数据的集合；
		输入输出是数据传送的过程；数据流；

			按文件的组织形式分类：
				asccii文件：
					要求在外存上以ascii代码形式存储，则需要在存储前进行转换；又称文本文件
				二进制文件：
					数据在内存中是以二进制形式存储，如果不加以转化地输出到外存，即二进制文件；

		数据如何存储到硬盘上的呢？
			字符一律按ascii形式存储，数值型数据既可以用ascii形式存储，也可以用二进制形式存储；
			例如： 1000
				ascii方式：占5byte，将1000每个数值都对应一个ascii，即占1 btye；
				二进制方式： 将1000直接按二进制处理；

		两者的特点：
			1、ascii方式一般会占用更多的空间，而且需要花费转换时间（二进制（内存中）---》 ascii）；

		用途：
			如果只是程序使用的信息，可以直接以二进制形成固化到本地，会更快！

		文件缓冲区：
			文件缓存系统：
				系统自动地在内存区为程序中的每一个只在使用的文件开辟一个文件缓冲区；
				只开辟一个缓冲区，读时，作为输入缓冲区，写时，作为输出缓冲区；

			写操作：
				从内存向C盘输出数据必须先送到内存中的缓冲区，装满缓冲区后一起送到磁盘去；
			读操作：
				计算机从磁盘读取数据时，一次从磁盘文件将一批数据输入到内存缓冲区，然后再从缓冲区逐个地将数据送到程序数据区；


		文件类型指针：
			缓冲文件系统中，文件类型指针又称文件指针是一个非常重要的概念；
			每个被使用的文件都在内存中开辟一个相应的文件信息区，用来存放文件相关信息；
			stdio.h中顶一个结构体：FILE
			一般只需要定义和使用文件指针；
			文件指针指向某个记录文件信息的内存区，通过改内存区的信息就能够访问改文件；

		定义文件指针：
			FILE * fp



		***************************************************************************************************************
		打开和关闭文件：
			打开文件：
				为文件创建相应的信息区和文件缓冲区；
				fopen(文件名，打开方式)，返回一个文件指针,如果打开失败将返回NULL；
			关闭文件：
				释放文件的信息区和文件缓冲区；
				fclose(文件指针), 返回值：0表示指针关闭，EOF（-1）表示关闭失败；
				当程序结束时，不关闭已经打开的文件可能造成数据丢失：
					在向文件写数据时，是先将数据输出到缓冲区，待缓冲区充满后才正式输出给文件；


			三个标准的流文件：
				标准输入文件： stdin文件指针变量
				标准输出文件： stdout
				标准出错输出： stderr

				程序运行时系统自动打开这个三个标准流文件；

		顺序读写数据文件：
			在打开文件后，进行的就是读写文件操作；
			库函数：单个字符操作
				fgetc(fp)： 从fp文件指针所代表的文件中读取一个字符；
							失败时返回文件结束标志EOF（-1）；
							getc函数和fgetc一样的功能

				fputc(ch, fp): 把字符ch写到文件指针变量指向的文件中；
							成功时返回ch；
							失败时返回文件结束标志EOF（-1）；
							putc函数和fputc一样的功能；

				feof(fp): 检查文件尾标志是否已被读取过了；
							如果返回值为1表示已经读到文件最后了；
				

			怎么向文件读写一个字符串：
				fgets(str, n, fp):
					从fp指向的文件读取一个长度为n-1的字符串，放置到字符数组str中；长度为n-1原因：系统默认为为字符串添加'\0';
					成功返回地址，失败返回NULL；

				fputs(str, fp):
					将str所指向的字符串写到文件指针指向的文件中；
					成功返回0，失败返回非0；

			格式化的方式读写文件：
				用途：
					格式化输出log，方便阅读；

				fprintf(fp, str_format, 输出表列)
				
				fscanf(fp, str_format, 输入表列)
				由于输入输出时存在ascii码转二进制的过程，对程序效率方面有所影响；
				建议不要使用上述函数；
				可以通过fread和fwrite哈四年进行二进制的读写；

			二进制方式向文件读写一组数据：
				fread(buffer, size, count, fp);
					buffer: 地址，用来存放从文件读入的数据的存储区的地址；
					size: 读取的字节数；
					count：要读多少个数据项；一个数据项大小为size；一般这里的编程技巧时：将count一直设置为1；
				fwrite(buffer, size, count, fp)


		随机读写数据文件：
			背景：
				文件FILE结构体变量中的成员：文件位置标记，记录了在该文件的游标；
				对文件进行顺序读写比较容易理解，也易操作，但是有时效率不高；
				比如，我就想取第100个byte；

			引出：
				随机访问可以对任意位置上的数据进行访问；

			技术支持：
				文件FILE结构体变量中的成员：文件位置标记；

			概念：
				位置：
					文件头
					读写当前位置
					文件尾

			库函数：
				rewind（fp）: 使文件位置标记重新返回文件的开头；
							函数无返回值；

				fseek(fp, 位偏移， 起始点)：
					改变文件位置标记；
					起始点：
						0：文件开始位置；
						1：文件当前位置；
						2： 文件末尾；
					位偏移：
						以起点位置为基点，向前移动多个字节；
						该参数类型是long类型，code参数时，最好使用10L的形式，数字的末尾加L表示long类型；

				ftell(fp):
					测定文件位置标记的当前位置；
					返回long类型，距文件头多少字节；
					失败时返回： -1L；


		文件读写的出错检测：
			目前来说：出错检测函数频率偏低；
			库函数：
				ferror(fp):
					返回值为0表示未出错；

				clearerr(fp)：
					使文件出错标志和文件结束标志置0；
					用来清除出错标志状态；

				

*/

#include <stdio.h>
#include <stdlib.h>

void test01()
{
	FILE* fp;
	char ch, filename[10];

	printf("please input file name: ");
	scanf("%s", filename);
	getchar();     // filter "\n"

	if ((fp = fopen(filename, "w")) == NULL)
	{
		printf("cannot open file\n");
		exit(0);
	}

	printf("please input # show exit: ");
	ch = getchar();

	while (ch != '#')
	{
		fputc(ch, fp);
		putchar(ch);
		ch = getchar();
	}

	fclose(fp);
	putchar(10);
	return 0;

}


int main()
{
	test01();

	return 0;
}